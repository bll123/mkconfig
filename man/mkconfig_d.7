.\"
.\" $Id$
.\" $Revision$
.\"
.\" mkconfig_d.7
.\"
.\" Copyright 2011 Brad Lanam  Walnut Creek CA USA
.\"
.\" brad.lanam.di_at_gmail.com
.\"
.\"
.\"  Notes on terminology:
.\"    check variable - the variable name for the check.
.\"    directive - a command from the mkconfig config file.
.\"      [was check command ]
.\"    mkconfig config file - file where mkconfig directives are read from
.\"       not to be confused with "config.h".
.\"    output file - file to which language units output is written
.\"    options file -
.\"    cache file -
.\"    lib file - output libraries file created by mkreqlib.sh
.\"
.\" from perl manual pages...
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\"
.TH mkconfig_d 7 "20 Sep 2011"
.SH Name
mkconfig_d \- mkconfig D language units
.\" .SH Synopsis
.SH Description
The D language units create an import file for use by D programs.
.SH D Language Units
.TP
.B d\-main
.br
The d\-main unit creates a configuration file for D programs.
.RS
.TP
\fBstandard\fP
.br
Executes any \fIStandard\fP checks for the D language.
Currently there are checks to see if the 'string' type is valid and
to see if the tango library is in use.  If 'string' is not valid, an
alias is added to the configuration file.  The tango library check
creates a check variable named '_d_tango_lib'.
.RS
.PP
Check variables are output as type enum where possible.  Other variables
are also output as enums where possible.
.PP
.Vb
.B e.g. D2
enum bool _d_tango_lib = false;
enum int _csiz_long_double = 16;
enum int D_VERSION = 2;
enum string SYSTYPE = "Linux";
.B e.g. D1
enum : bool { _d_tango_lib = true };
enum : int { _csiz_long_double = 16 };
enum : int { D_VERSION = 1 };
string SYSTYPE = "Linux";
.Ve
.RE
.TP
\fBimport\fP name\-\of\-module
.RS
Checks to see if module can be imported.
.PP
.B e.g.
.br
import std.stdio
.br
Check Variable: _import_std_stdio
.RE
.TP
\fBlib\fP function [libs, ...]
.br
Check to see if the library function \fIfunction\fP exists.
If the optional \fIlibs\fP are specified,
the test will try first without the libraries, then with
the first set of libraries specified linked in, then the next set, etc.
Sets of libraries to be tested are separated by commas.
If link libraries are specified, any value in the cache is ignored,
and the function is retested.
.TP
\fBclass\fP class [libs, ...]
.RS
Check to see if the class \fIclass\fP exists.
If the optional \fIlibs\fP are specified,
the test will try first without the libraries, then with
the first set of libraries specified, then the next set, etc.
Sets of libraries to be tested are separated by commas.
.RE
.TP
\fBmember\fP struct\-name member
.RS
Check to see if \fImember\fP is a member of \fIstruct\-name\fP.
.RE
.TP
\fBsize\fP type\-name
.RS
Check the size of type\-name
.RE
.TP
\fBtype\fP type\-name
.RS
Check to see if type\-name exists.  This is used internally
to see if 'string' is valid.
.RE
.PP
.B D Language Units \- C Language Interface
.PP
All C language types are converted to the corresponding D language
type when output (operating system, architecture and compiler dependent).  Any
variables with two leading underscores will be converted to '_t_'.
.TP
\fBchdr\fP header
.RS
Checks to see if the C Language \fIheader\fP exists.
The \fIchdr\fP and \fIcsys\fP directives must appear
before other C language directives.  The appropriate headers
must be checked so that structure, typedef, defines and declarations
may be extracted.
.PP
.B e.g.
.br
chdr stdlib.h
.br
Check Variable: _hdr_stdlib
.RE
.TP
\fBcsys\fP header
.RS
Checks to see if the C language sys/\fIheader\fP exists.
The \fIchdr\fP and \fIcsys\fP directives must appear
before other C language directives.
.PP
.B e.g.
.br
csys types.h
.br
Check Variable: _sys_types
.RE
.TP
\fBcsizes\fP
.RS
Checks the sizes of the standard C data types.  This directive
is required for most of the D/C language interface directives.
Operating system, architecture and compiler dependent.
.PP
.Vb
.B Output:
enum int _csiz_char = 1;
enum int _csiz_short = 2;
enum int _csiz_int = 4;
enum int _csiz_long = 8;
enum int _csiz_long_long = 8;
enum int _csiz_float = 4;
enum int _csiz_double = 8;
enum int _csiz_long_double = 16;
.Ve
.RE
.TP
\fBclib\fP function [libs, ...]
.RS
Check to see if the C library function \fIfunction\fP exists.
If the optional \fIlibs\fP are specified,
the test will try first without the libraries, then with
the first set of libraries specified linked in, then the next set, etc.
Sets of libraries to be tested are separated by commas.
.PP
.B e.g.
.br
clib quotactl
.br
Check Variable: _clib_quotactl
.PP
clib bindtextdomain -lintl, -lintl -liconv
.br
[will test w/o any library, then with -lintl, then with both -lintl and -liconv]
.RE
.TP
\fBcdefine {int|hex|float|string}\fP def
.RS
Checks if a C #define of \fIdef\fP exists.
A D language 'enum' will be output to the output file.
.PP
.B e.g.
.br
cdefine hex LC_ALL
.br
cdefine string _PATH_MOUNTED
.br
Check Variable: _cdefine_LC_ALL
.br
.RE
.TP
\fBctype\fP {int|float} type\-name
.RS
\fItype\-name\fP will be converted to a D language alias for the
type.  The size of the type will be determined,
and the corresponding D type will be used to alias the type.
The C language type will be renamed to C_TYP_<type>.  All further
instances of that type in the output will also be converted.
The \fIint\fP or \fIfloat\fP keyword
indicates whether or not \fItype\-name\fP is an integer type
or a floating point type.
For structures, character pointers, function pointers
or if the actual typedef is wanted, use ctypedef.
.PP
.Vb
.B e.g.
ctype int uid_t
Check Variable: _ctype_uid_t
.B Output:
alias uint C_TYP_uid_t;
static assert ((C_TYP_uid_t).sizeof == 4);
enum int _ctype_uid_t = 4;
.Ve
.RE
.TP
\fBctypedef\fP type\-name
.RS
Checks for the typedef \fItype\-name\fP, and if it exists,
outputs the D language alias for that typedef.  Unlike the \fIctype\fP
directive, the size of the object is not determined.  The typedef
is converted to a D alias as is and output.  If the type that is
converted from is not defined, further \fIctype\fP or
\fIctypedef\fP directives will be need to be added to the configuration
file.
.PP
.Vb
.B e.g.
ctypedef __caddr_t
ctypedef caddr_t
.B Output:
alias _t_caddr_t caddr_t;
// from: typedef __caddr_t caddr_t;
alias char *_t_caddr_t;
// from: typedef char * __caddr_t;
.Ve
.RE
.TP
\fBcmacro\fP macro\-name req\-header [req\-hdr2 [...]] rettype [type1 ...]
.RS
\fImacro\-name\fP will be converted to a D language function to replace the
macro.  The C language macro will be renamed to C_MACRO_<macro>.
\fIreq\-header\fP is the list of headers where \fImacro\-name\fP will be
found.  The return type of \fImacro\-name\fP must be listed
after the required headers, and if
\fImacro\-name\fP takes arguments, then the list of types
must be specified at the end of the cmacro directive.  The return
type is only used for D version 1.  D version 2 will always set the macro
return type to 'auto'.
The 'awk' program is a requirement for this directive.
.PP
.Vb
.B e.g.
cmacro MIN sys/types.h int int int
Check Variable: _cmacro_MIN
auto C_MACRO_MIN(int a, int b) { return ((a) < (b) ? (a) : (b)); }
enum bool _cmacro_MIN = true;
.Ve
.RE
.TP
\fBcstruct\fP struct\-name
.br
\fBcunion\fP union\-name
.br
\fBcenum\fP enum\-name
.br
.RS
Checks to see if struct \fIstruct\-name\fP or a typedef
definition for \fIstruct\-name\fP
exists.  The structure will be modified for the D language and output
to the output file.  Note that any types used by the structure must
be checked for first using the \fIctype\fP or \fIctypedef\fP directives.
The structure will be renamed to C_ST_struct\-name (C_UN for unions, C_ENUM
for enums).
The 'awk' program is a requirement for this directive.
.PP
.Vb
.B e.g.
ctype int __time_t
ctype int __suseconds_t
cstruct timeval
.B Output:
struct C_ST_timeval
 {
 C_TYP___time_t tv_sec;
 C_TYP___suseconds_t tv_usec;
 };
alias long C_TYP___time_t;
alias long C_TYP___suseconds_t;
static assert ((C_TYP___time_t).sizeof == 8);
static assert ((C_TYP___suseconds_t).sizeof == 8);
static assert ((C_ST_timeval).sizeof == 16);
enum bool _cstruct_timeval = true;
enum int _ctype___time_t = 8;
enum int _ctype___suseconds_t = 8;
.Ve
.RE
.TP
\fBcmember\fP struct\-name member
.RS
Checks to see if \fImember\fP is a member of \fIstruct\-name\fP.
The \fIcstruct\fP directive for the structure must appear
before this directive.
.PP
.Vb
.B e.g.
cmember statvfs f_basetype
.B Output:
enum bool _cmem_statvfs_f_basetype = false;
.Ve
.RE
.TP
\fBcmembertype\fP struct\-name member
.RS
Gets the type of \fIstruct\-name\fP.\fImember\fP.
The \fIcstruct\fP directive for the structure must appear
before this directive.
.PP
.Vb
.B e.g.
cmembertype getquota_args gqa_uid
.B Output:
enum bool _cmembertype_getquota_args_gqa_uid = true;
.RE
.TP
\fBcmemberxdr\fP struct\-name member
.RS
Aliases the appropriate xdr function for \fIstruct\-name.member\fP.
The \fIcstruct\fP directive for the structure must appear
before this directive.
.PP
.Vb
.B e.g.
cmemberxdr getquota_args gqa_uid
.B Output:
alias xdr_int xdr_gqa_uid;
enum bool _cmemberxdr_getquota_args_gqa_uid = true;
.Ve
.RE
.TP
\fBcdcl\fP [args [noconst]] function
.RS
Checks to see if \fIfunction\fP is declared and outputs the
declaration to the output file.  If the \fIargs\fP keyword is
present, the number of arguments to the function is counted,
and the check variables: _c_args_function, _c_arg_N_function,
and c_type_function are written to the output file.
_c_args_function indicates the number of arguments that should be passed to
the function. _c_arg_N_function indicates the type of argument where \fIN\fP
refers to the argument position.
_c_type_function indicates the return type
of the function.  If the \fInoconst\fP keyword is present, all 'const'
keywords are stripped from the type.  All C declarations are wrapped in
an 'extern (C) { ... }' block in the output file.
The 'awk' program is a requirement for this directive.
.PP
.Vb
.B e.g.
cdcl args noconst setmntent
.B Output:
extern (C) {
 FILE *setmntent (const char *_t_file, const char *_t_mode) ;
}
enum string _c_arg_1_setmntent = "char *";
enum string _c_arg_2_setmntent = "char *";
enum string _c_type_setmntent = "FILE *";
enum bool _cdcl_setmntent = true;
enum int _c_args_setmntent = 2;
.Ve
.RE
.SH See Also
iffe(1) autoconf(1) dist(7) mkconfig(7) mkconfig_c(7) mkconfig_env(7)
.SH Bugs
Send bug reports to: brad.lanam.di_at_gmail.com
.SH Website
http://www.gentoo.com/di/mkconfig.html
.SH Author
This program is Copyright 2011 by Brad Lanam, Walnut Creek CA
.PP
Brad Lanam, Walnut Creek, CA (brad.lanam.di_at_gmail.com)
